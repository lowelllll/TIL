# 애플리케이션층 (응용 계층)
<b>통신 서비스를 실현하는 것</b>
### 애플리케이션층 역할
1. 통신 서비스를 실현하는 것  
      컴퓨터끼리 주고받기를 사용자가 이용할 수 있는 '통신 서비스'라는 형태로 만드는 것
     서버와 클라이언트로 실현함.
2. 애플리케이션 프로토콜  
    통신 서비스에 대한 서버와 클라이언트의 주고 받기를 정하는 프로토콜
    HTTP,SMTP,POP,FTP 등

### 애플리케이션 헤더
애플리케이션층에서 추가되는 헤더, 요청과 응답에 관한 정보가 들어있음.   

## HTTP 프로토콜
> WWW 서비스를 지지하고 있는 프로토콜  

- 하나의 요청에 대해 하나의 응답을 반환하는 프로토콜 (무상태성 프로토콜)   
     실제로 페이지를 구성하고 있는 파일 수 만큼 작업을 반복함.
- 요청 패킷, 응답 패킷  
     요청(request)와 응답(response) 두 종류의 패킷을 사용하여 텍스트 형식으로 주고 받기를 수행함.(HTTP 헤더)

### 무상태 프로토콜
> 한 번으로 끝나는 프로토콜

HTTP 프로토콜은 '요청된 데이터를 반환하는 것'을 목적으로 만들어져 접속 상태를 유지한 채로 주고받기를 계속 할 수 없음.  
한번의 요청과 응답으로 통신은 완결, 과거에 수행한 통신과 관련을 맺는 경우는 없음

### 쿠키(Cookie)
HTTP로 한번 요청을 했던 사용자를 기억해야하는 서비스는 어떻게 해야할까?  
<b>쿠키</b>로 해결

- HTTP 프로토콜의 주고 받기에 관한 정보(Cookie)를 클라이언트측에 저장해 두어 다음 통신 때 그 정보(Cookie)를 서버에게 제시하면 서버는 사용자를 지정하고 이전 회에서 이어진 통신으로 취급할 수 있음.

쉽게 말해 <b>회원증</b> 기능을 함.

### CGI를 사용한 쿠키의 주고 받기
쿠키는 HTTP 프로토콜의 정규 장치가 아니므로 CGI 등 클라이언트로부터 요청에 맞게 웹 페이지를 작성하는 장치와 함께 사용함.

#### 일반 웹 페이지의 주고 받기   
서버가 응답 패킷을 준비함.

#### CGI를 사용해 주고 받기  
서버로부터 요청을 받아 CGI 프로그램이 응답 패킷을 준비함.  
쿠키를 사용하는 경우 헤더 부분에 쿠키와 '클라이언트에서 쿠키를 저장하기 위한 명령'을 써넣음.   
클라이언트는 쿠키를 저장함.  

#### 쿠키의 주고 받기
1. 클라이언트 : 요청
2. 서버 -> CGI 프로그램 : 응답 패킷의 응답 헤더에 쿠키의 저장을 의뢰하는 명령을 써 넣음 (Set-cookie)
3. 클라이언트 : 부여된 쿠키 저장

클라이언트가 다시 동일한 웹 사이트로 요청할 시  
1. 클라이언트 : 요청 패킷의 요청 헤더에 이전에 서버로부터 부여된 쿠키를 써 넣음
2. 서버 -> CGI 프로그램 : 쿠키를 보고 사용자를 지정하여 처리한 웹 페이지를 작성
3. 클라이언트 : 이전 통신을 근거로 웹 페이지 표시

쿠키는 유효기간이 있고 기간이 지난 쿠키는 클라이언트에 의해 자동적으로 삭제됨.

## 전자메일

### 명령과 응답
명령(command) : 클라이언트에서 서버로의 호출
응답(response) : 서버에서 클라이언트로의 호출 

명령과 응답은 헤더+데이터라는 형태를 취하지 않고 단독으로 트랜스포트층에 전달됨. (데이터가 없다고 보면 됨)

### SMTP
- - - 
> 메일을 수신인의 메일 서버까지 전송하는 프로토콜

SMPT 프로토콜 명령은 4문자 알파벳, 응답은 3자리 숫자로 나타냄.  
ex) 요청 HELO<mail.naver.com> (안녕) , 응답 250 (용건을 말하세요)

### POP 
- - - 
> 메일 서버로부터 자기 앞으로 온 전자메일을 받을 때 사용하는 프로토콜(version 3를 주로 사용 POP3)

POP 프로토콜 명령은 4문자 알파벳 , 응답은 '+OK','-ERR'로 나타냄.  
ex) 응답 +OK QPOP mail.naver.com (누구세요?) , 요청 USER lowell (전 lowell이에요)

- - - 
### 문자코드 
전자메일처럼 문자를 주고 받는 통신 서비스에서는 문자 그 자체가 아닌 문자 코드를 주고 받음. (ASCII)

<b>인코딩(Encoding)</b>
일반적으로 사람이 이해하는 언어를 컴퓨터가 이해하는 언어로 변환하는 것

<b>디코딩(Decoding)</b>
컴퓨터가 이해하는 언어를 다시 사람이 이해하는 언어로 변환하는 것

### MIME (Multipurpose Internet Mail Extension)
> 정해진 원칙에 따라 파일을 ASCII 문자열로 인코딩하고 어떻게 인코딩 했는지에 대한 정보를 첨부해 수신인에게 보냄으로 수신측이 올바른 방법으로 디코딩 할 수 있도록 하는 장치

<b>왜 쓸까?</b>

전자메일의 제약
1. 제목에는 한글을 사용할 수 없다.
     전자메일의 헤더로 사용할 수 있는 것은 문자코드 ASCII 뿐..
2. 텍스트 밖에 보낼 수 없다.
     그림,음악 데이터 X

<b>MIME는 이런 제약에 구애 받지 않고 제목에 한글을 사용하거나 첨부파일이라는 형태로 텍스트 이외의 데이터를 보낼 수 있음.</b>

# 트랜스포트층 (전송계층)
<b>통신을 실현하는 것 , 애플리케이션층과 네트워크층의 중개역할<b>

### 트랜스포트층의 역할
1. 데이터를 상대에게 전달하는 것  
    데이터를 전달할 때 문제가 발생한 경우 통신 서비스에 맞는 방법으로 그것을 처리함.
2. 상대 애플리케이션층에 있는 어떤 프로토콜에게 전달할 것인가?  
    TCP,UDP

### PORT
> 애플리케이션층에는 서비스의 수만큼 프로토콜이 존재하는데 그 중 목적한 프로토콜을 지정하기 위해 사용하는 장치  

각각의 개별 프로토콜로 가는 현관문

- 각 포트에는 포트 번호가 붙어있으며 통신을 수행할 때 포트 번호를 사용하여 보낼 곳(프로토콜)을 지정함.
- 프로토콜을 식별할 수 있고 다른 통신 서비스를 동시에 사용할 수 있음.
- 포트 번호는 0~65535번 까지 존재
- 0~1023번 까지는 통신 서비스마다 미리 예약되어있음.
- 그 외 포트는 사용자가 임의로 설정 가능하며 이때 통신하는 컴퓨터 간의 어떤 포트번호를 사용할지에 대한 인식이 통일되어있어야함.

## TCP (Transimission Control Protocol)
> '데이터를 안전하고 확실하게 전달할 것'을 목표로 둔 프로토콜. 데이터 전송의 정확성,신뢰성을 중시함.

### 커넥션형 통신
1:1 통신 , 데이터를 확실히 전달하기 위해 수신측과 1:1 통신을 함.

1. 수신측이 데이터를 받을 수 있는 상태인지 확인 후 통신 개시, 통신을 연결
2. 데이터를 정해진 크기로 분할하고 TCP 헤더에 붙여 순서대로 송신함.  
    트랜스포트층에서 취급하는 데이터의 단위 : 세그먼트 (segment)
3. 데이터를 다 보냈으면 통신을 종료함.

### 애플리케이션층에 전달
수신측은 전달받은 데이터를 원래의 형태로 다시 맞춘후 애플리케이션층에 전달함.
1. TCP 헤더의 정보를 보고 데이터를 순서대로 맞춤
2. TCP 헤더를 가지고 데이터를 다시 맞춤. (붙임)  
3. 애플리케이션층의 프로토콜에 전달. (port 번호를 보고 어떤 프로토콜에 전달할지 판단)

- - -

### 확실히 어떻게 전달하느냐?
---
<b>1. TCP는 확실한 주고받기를 위해 통신 상태에 대해 연락.<b>

#### 컨트롤 플래그(control flag)  
통신 상대에게 통신 상태를 전달하는 수단으로 TCP 헤더에 6비트로 구성.

<b>항목</b>  
- URG : 1이면 세그먼트가 긴급한 데이터를 갖고있다.
- ACK : 1이면 통신 확인에 대해 알았다고 응답하는 것. (확인 응답)
- PSH : 1이면 세그먼트를 바로 애플리케이션층에 전달함.
- RST : 1이면 통신을 강제적으로 해제.
- SYN : 1이면 통신 개시를 요청.
- FIN : 1이면 통신 종료.

<b>핸드셰이크(handshake)</b>  
통신 세계에서 일반적으로 상대와 서로 확인해 가며 주고 받는 것.

#### 데이터 량의 확인
실제로 통신을 시작하기 전 서로가 양쪽을 모두 다룰 수 있는 데이터 량을 확인함.
- 세그먼트 사이즈
- 윈도 사이즈  
     데이터를 한번에 받을 수 있는 양

수치는 작은 쪽으로 맞춰짐 

#### 통신 해제
TCP 헤더의 컨트롤 플래그를 사용하여 연락을 취함.

--- 

<b>2. 데이터가 무사히 전달 되었는지 서로 하나씩 확인.</b>

#### 주고 받기의 흐름
TCP 헤더에는 데이터의 순서를 나타내는 번호(시퀀스 번호)가 적혀있음.  
헤더를 확실히 받기 위해서 이 번호를 사용하여 주고받기를 수행함.

1. 송신측이 TCP 헤더에 시퀀스 번호를 쓰고 세그먼트를 보냄
2. 수신측이 시퀀스 번호를 보고 순서대로 전달되고 있는지 확인하고 전달된 세그먼트의 다음 번호를 송신측에게 알려줌.
3. 송신측이 무사히 전달됬다는 것을 확인하고 다음 세그먼트를 보냄
4. 수신측이 다음 세그먼트를 받고 시퀀스 번호를 보고 순서대로 나열함. 

#### 모아보내기
세그먼트는 하나씩 보내는 것 보다 몇 개씩 모아서 보내는 것이 효율적.  
통신을 시작할 때 정한 윈도 사이즈까지라면 확인 응답을 기다리지 않고 모아서 보낼 수 있음.

#### 윈도 사이즈 변경
윈도 사이즈는 통신 도중 변경 가능함.  
네트워크가 비어있을 때는 크게하고 혼잡할 때는 작게하는 등 상황에 맞게 조절 가능.

---

### 문제 발생시 처리 
TCP는 송수신중 문제가 발생하면 세그먼트를 재 전송함.

<b>확인 응답이 없을 경우 재전송.</b>  
일정  시간을 기다려도 확인 응답이 없을 시 이유를 불문하고 송신측은 세그먼트를 재전송함.

1. 세그먼트 지연 , 분실   
    송신 도중 세그먼트가 행방불명 되는 경우, 수신측은 확인 응답을 보낼 수 없음.
2. 확인 응답의 지연 및 분실  
    확인 응답 자체가 네트워크상에서 행방불명 되는 경우 (세그먼트가 중복되면 하나를 파기함)
3. 데이터 파손  
    송신 도중 데이터가 깨지는 경우 수신측은 그 데이터를 파기하고 확인 응답은 보내지 않음. 깨졌는지 아닌지는 헤더의 체크섬이라는 값을 사용하여 판단함.

일정 횟수 이상을 재전송해도 확인 응답이 오지 않는 경우 송신측이 강제로 통신을 해제함. (Control falg의 RST를 1)


### 수신측의 처리
1. 애플리케이션층에 전달.  
    - 수신측에서 TCP 헤더에 적힌 포트 번호를 보고 지정된 애플리케이션 프로토콜에 데이터를 전달함.
    - 데이터가 하나의 세그먼트로 묶여있을 경우 헤더를 제거하고 전달, 두개 이상으로 분할 되어있는 경우는 세그먼트를 조립한 후 전달함.

조립한 데이터를 지정된 애플리케이션 프로토콜에게 전달하면 TCP의 일은 끗

## UDP 
> 통신 속도를 중시한 프로토콜

### 비 커넥션형 통신
> 사전 의논하지 않고 일방적으로 데이터를 보냄.  

송신측 : 그냥보냄 막보냄 재전송안함.  
수신측 : 확인 응답? 안보냄 데이터 파기함ㅋ

### 동시에 보내기
UDP는 여러 상대에게 동시에 데이터를 보낼 수 있음.

<b>멀티캐스트(multicast)</b>  
복수의 특정인에게 보내는 것

<b>브로드 캐스트(broad-cast)</b>  
불특정 다수에게 보내는 것


### UDP가 하는일
- 데이터가 깨지지 않았는지 확인하고 깨졌다면 파기
- UDP 헤더를 제거하고 지정된 애플리케이션 프로토콜에 전달.

<b>실시간성이 중요시되는 통신이나 데이터가 작은 네트워크 관리의 통신 등에  사용됨</b>

## refer
[TCP/IP가 보이는 그림책](http://www.cyber.co.kr/shop/goods/goods_view.php?goodsno=5993&category=020040)
