# 트랜잭션
> 복수 쿼리를 한 단위로 묶은 것

갱신은 단일 쿼리만으로 구성되는 것이 아닌 복수쿼리를 연속적으로 수행하는 경우가 대부분임.

## MySQL에서 트랜잭션 사용하기
MySQL에서 트랜잭션 구조를 사용하기 위해선 `InnoDB형` 테이블을 작성함.

### 트랜잭션의 특성
<i><b>'ACID'</b> 특성</i>

1. Atomicity (원자성)
2. Consistency (일관성)
3. Isolation (고립성 or 격리성)
4. Durability (지속성)

#### 원자성
<b><i>전부 성공하거나 전부 실패하거나</i></b>

> 데이터의 변경을 수반하는 일련의 데이터 조작이 전부 성공할지 전부 실패할지를 보증하는 구조.

- 시스템이 정상 동작하는 상황에서 오류뿐만이 아닌 클라이언트에서 서버로의 통신이 끊긴다거나 서버가 다운된 경우에 COMMIT된 것 이외는 ROLLBACK을 해야함.

#### 일관성
> 데이터 조작 전후에 그 상태를 유지하는 것을 보증하는 것. 일관성을 유지하기 위한 구조

ex) 유니크 제약을 설정하면 중복된 사용자 번호를 저장할 수 없음.

### 고립성(격리성)
> 일련의 데이터 조작을 복수 사용자가 동시에 실행해도 각각의 처리가 모순없이 실행되는 것을 보증하는 것

- 어떤 데이터를 사용자 2명이 동시에 조작할 경우 데이터베이스는 데이터베이스 오브젝트인 테이블에 대해 잠금을 걸어 후속처리를 블록함.  
후속처리는 해당 잠금이 해제될 때(COMMIT,ROLLBACK)까지 대기하며 올바른 처리를 함.

#### 잠금단위
- 테이블 전체
- 블록
- 행
    - 주로 행단위 잠금 기능 사용.
    - 사용자가 id가 1인 행을 조작하는 경우 그 행에 잠금이 걸림.

InnoDB형의 테이블은 사용자가 단순히 값을 참조하는 경우에는 읽기가 블록되지 않음.  
테이블을 갱신하는 자가 소수이고 참조하는 사용자가 많은 경우에는 사용자의 <b>동시성</b>,<b>병렬성</b>이 높아짐

#### 모순이 없는 상태
> 복수의 트랜잭션이 순서대로 실행되는 경우와 같은 결과를 얻을 수 있는 상태. 병렬로 실행되지 않는 상태

#### 직렬화 가능
> DBMS에서 격리수준으로 구현하고 제공하는 것

- 직렬화 가능의 고립성에서는 항상 동시에 동작하는 트랜잭션이 1개의 이미지가 되어 성능면에서 실용적이지 않음.

##### 격리수준
> 한 트랜잭션을 다른 트랜잭션에서 수정한 데이터 내용으로부터 격리하는 정도 
- 직렬화 가능으로부터 격리수준을 완화해 직렬화 가능 이외에 자신이 아닌 다른 트랜잭션의 영향을 받는 것을 허용하는 단계.  

1. 커밋되지 않은 읽기
2. 커밋된 읽기
3. 반복 읽기
4. 직렬화 가능

숫자가 낮을 수록 완화된 격리수준임.

격리수준이 완회되면서 직렬화 가능에서는 발생하지 않았던 현상이 발생함.
- <b>더티읽기</b>
    - 어떤 트랜잭션이 커밋되기 전에 다른 트랜잭션에서 데이터를 읽는 현상
- <b> 애매한 읽기</b>
    - 어떤 트랜잭션이 이전에 읽어들인 데이터를 다시 읽을 때 2회 이후의 결과가 1회때와 다른 현상
- <b>팬텀읽기 </b>
    - 어떤 트랜잭션을 읽을 때 선택할 수 있는 데이터가 나타나거나 사라지는 현상.

### 지속성
> 일련의 데이터 조작을 완료하고 완료 통지를 사용자가 받는 시점에서 그 조작이 영구적이 되어 그 결과를 잃지 않는 것

- 시스템이 정상일 때만이 아닌 데이터베이스나 OS의 이상종료, 즉 시스템 장애도 견딜 수있다는 뜻
- 많은 데이터베이스는 트랜잭션 조작을 하드디스크에 <b>로그</b>로 기록하고 시스템에 이상이 발생하면 그 로그를 사용해 이상 발생 전의 상태까지 복원하는 것을 지속성을 실현함.

## 다른 커넥션에서는 어떻게 보일까
기본적으로 DDL에 따른 테이블 작성과`DML에 의한 데이터 저장은 트랜잭션이 커밋되기 전까지는 다른 커넥션에서 보이지 않음.

이에 상관없이 다른 커넥션에서 보이는 이유
- DDL에 따른 암묵적인 커밋
    MySQL이나 Oracle에서는 DDL 실행시 암묵적인 커밋이 발생함. 때문에 한개의 커넥션에서 실행된 `CREATE TABLE`이 성공하면 다른 커넥션에서도 참조할 수 있음.
- 오토커밋 설정
    ##### 트랜잭션의 개시가 명시적으로 지정되지 않았을 때 트랜잭션을 구별하는 방법
    1. 하나의 SQL문이 하나의 트랜잭션으로 구분됨(오토커밋)
    2. 사용자가 `COMMIT` 또는 `ROLLBACK`을 실행하기 까지가 하나의 트랜잭션이 됨.

    ##### 기본 설정이 오토커밋인 DBMS
    - MySQL
    - PostgreSQL
    - SQL Server

## 잠금 타임아웃과 교착상태
### 잠금 타임아웃
갱신과 참조는 서로를 블록하지 않지만 갱신과 갱신이 부딪히는 경우에는 나중에 온 갱신이 잠금 대기 상태가 됨.   
잠금 해제를 기다리고 있는 쪽에서는 잠금을 기다리거나 기다리지 않거나, 기다린다면 어느정도 기다릴지를 설정할 수 있음. 유효값은 1초 이상.
```
# 잠금 대기 상태에서 5초 후 잠금 타임아웃되는 설정.
>set innodb_lock_wait_timeout= 5;
```
#### 잠금 대기로 타임아웃이 발생하는 경우 DBMS로부터 롤백되는 단위
- 해당 트랜잭션 전체를 롤백
    - 타임아웃 오류 후 명시적으로 `ROLLBACK`을 실행.
    - `innodb_rollback_on_time` 시스템 변수 설정.
- 쿼리만 롤백.(기본)

### 교착상태
트랜잭션 a가 테이블 a의 잠금을 얻고(쓰기) 트랜잭션 b가 테이블 b의 잠금을 얻었을 때, 이 잠금을 유지한 채 서로 잠금을 건 자원에 잠금이 필요한 처리(insert,update,delete)를 실행하면 아무리 기다려도 상황이 바뀌지 않음.

잠금 타임아웃은 일정 시간 기다리면 상황이 개선될 가능성이 있지만 교착 상태는 상황이 개선될 가능성이 없음.  
교착상태는 일반적인 데이터베이스에서 발생할 가능성이 있고 모든 것을 없앨 수는 없음.  
애플리케이션 쪽에서는 항상 트랜잭션이 교착상태를 일으켜 롤백되는 경우에 트랜잭션을 재실행할 수 있는 구조로 만들어야함.  

#### 교착상태의 발생 빈도를 낮추기 위한 방안들
##### DBMS 전반적인 대체
- 트랜잭션을 자주 커밋한다.
- 정해진 순서로 테이블(행)에 엑세스하게 한다.
- 필요 없는 경우에는 읽기 잠금 획득의 사용을 피한다.
- 쿼리에 의한 잠금 범위를 더 좁히거나 잠금 정도를 더 작은 것으로 한다.(행의 잠금,커밋된 읽기)
- 동시에 많은 연결에서 갱신 때문에 교착상태가 자주 발생한다면 테이블 단위의 잠금을 획득해 갱신을 직렬화 한다.
##### MySQL의 대책(innoDB)
- 테이블에 적절한 인덱스를 추가해 쿼리가 이를 이용하게 한다.

## refer
[데이터베이스 첫걸음](http://www.hanbit.co.kr/store/books/look.php?p_code=B5934047828)





