# 데이터베이스와 아키텍처

데이터베이스는 견고하게 유지되야함.  
문제가 발생할 때 마다 정지해서는 인프라로써의 역할을 다하지 못함.  

### 아키텍처
> 시스템을 만들기 위한 물리레벨의 조합.

- 어떤 기능을 가진 서버를 준비하고 어떠한 저장소나 네트워크 기기와 조합해 시스템 전체를 만들 것인가.
- 하드웨어와 미들웨어의 구성
- 시스템의 목적과 기능

### 아키텍처 설계
> 아키텍처(구성)을 시스템이 완수해야할 목적과 비교하면서 결정하는 것

### 아키텍처의 중요성
시스템에 요구되는 조건을 충족하기 위해 '어떤 아키텍처가 적당할까' 라는 것을 생각하지 않고 시스템 구축에 걸리는 비용을 산출하는 것은 불가능.

아키텍처, 설계는 시스템 개발 초반에 시행하는 일 중 매우 중요한 일

## 데이터베이스의 아키텍처 
### 1. 역사와 개요

데이터베이스에 관한 아키텍처의 역사
- stand-alone
- client/server
- WEB 3계층

### stand-alone 
> 데이터베이스가 동작하는 머신(DB server)이 LAN이나 인터넷 등의 네트워크에 접속하지 않고 독립되어 동작하는 구성.

- 데이터베이스만으로 시스템이 성립하는 가장 간단한 방법.
- 데이터베이스의 미들웨어(DBMS)와 애플리케이션 소프트웨어는 같은 DB 서버에서 동작하기 때문에 데이터베이스를 사용하고 싶은 사용자는 DB 서버가 설치된 장소까지 물리적으로 접근해 서버 앞에서 데이터베이스를 사용해야함.

#### stand-alone의 단점
1. 물리적으로 떨어진 장소 외에는 접근할 수 없음.
2. 복수 사용자가 동시에 작업할 수 없음.  
    - 네트워크에 연결되어있지 않기 때문에 서버를 사용할 수 있는 사람 수는 1명으로 한정됨.
3. 가용성이 낮음.     
    - 서버가 1대밖에 없으므로 1대에 장애가 발생하면 서비스가 정지함.
    - <b>가용성</b> : 시스템이 서비스 제공시간에 장애 없이 서비스를 계속 지속할 수 있는 비율이 어느 정도인가를 나타내는 개념.
4. 확장성이 부족함.     
    - 실제 머신이 1대밖에 없다는 것은 그 자체의 성능을 올리는 것 외에 개선 수단이 없다는 것을 의미.
    - 서버를 상위 기종으로 교환하거나 더 고성능의 부품으로 교환하기 위해 시스템을 정지해야해서 가용성을 점점 낮춤.

#### stand-alone의 장점
- 구축이 매우 간단해 소규모 작업이나 테스트를 빨리 할 수 있음.
- 보안이 매우 높음.(네트워크를 매개로 침입할 위험이 없기 때문)

### Client/Server 
> 데이터베이스 서버 1대에 복수 사용자의 단말이 접속하는 클라이언트/서버 구성

- 데이터베이스를 네트워크에 연결해 복수의 사용자가 물리적으로 떨어진 장소에서 데이터베이스를 접속할 수 있음.
- 데이터베이스 서버 1대에 복수 사용자의 단말이 접속할 수 있음.

`stand-alone`의 단점 1번,2번을 극복함.

#### client/server 구성의 단점
- 인터넷에서 직접 데이터베이스에 접속하는 것에 대한 보안 위험.
- 불특정 다수의 사용자가 사용하는 클라이언트에서의 애플리케이션 관리비용이 많이 드는 점.

<b>관리비용 문제란?</b>  
클라이언트/서버 시대엔 개인이 이용하는 PC에 애플리케이션을 설치해 동작하게 함.

인터넷을 통해 전 세계 불특정 다수의 사용자가 이용하는 애플리케이션은 각종 환겨에 대응해 애플리케이션을 작성해야하고, 각각에 대해 버전관리나 버그 수정 버전을 배포하는데 비현실적인 비용이 필요함.

<i>현재 스마트폰의 애플리케이션과 동일함.</i>

### WEB 3계층
> 시스템을 3가지 계층의 조합으로 구성. 현재 웹 시스템의 (거의)표준

- 비즈니스 로직을 실행하는 애플리케이션을 서버에서 관리해 비용을 절감하자는 요구가 나옴에 따라 `WEB 3계층` 구성이 등장함.
- 사용자로부터 직접적인 접속을 받는 역할을 웹 서버 계층에 한정하여 애플리케이션 계층과 데이터베이스 계층의 보안성을 높일 수 있음.
- 애플리케이션 계층에 비즈니스 로직을 집중해 애플리케이션 관리비용을 낮추는 구성이 됨.

#### 계층의 종류
- 웹 서버 계층
- 애플리케이션 계층
- 데이터베이스 계층

#### 웹 서버 계층
클라이언트로부터 접속 요청을 직접 받아 그 처리를 뒷단의 애플리케이션 계층으로 넘기고 그 결과를 클라이언트에게 반환.

- ex) 아파치(apache)

#### 애플리케이션 계층
비즈니스 로직을 구현한 애플리케이션이 동작하는 층.  
웹 서버로부터 연계된 요청을 처리하고 필요하면 데이터베이스의 계층(DB 서버)에 접속해 데이터를 추출하고 이를 가공한 결과를 웹 서버로 반환.

- ex) 톰캣(tomcat)



### 2. 가용성과 확장성
<b>`stand-alone` 단점 중 가용성과 확장성의 문제를 해결해보자.</b>

시스템은 알수 없는 원인으로 시스템 장애가 일어날 수 있음.

#### 가용성을 높이는 전략
1. 고품질-소수전략(심장과 동일)
    - 시스템을 구성하는 각 컴포넌트의 신뢰성을 높여 장애 발생률을 낮게 억제해 가용성을 높임.
2. 저품질-다수전략(신장과 동일)
    - '사물은 언젠간 망가진다'란 체념을 전제로 여분을 준비해둠.
    - 현재 많이 사용하는 전략.

#### 클러스터
> 동일한 기능의 컴포넌트를 복수 개 준비해 한 개의 기능을 실현하는 것.

<b>클러스터링</b> : 저품질-다수전략처럼 동일한 기능의 컴포넌트를 병렬화하는 것

#### 다중화
> 클리스터 구성으로 시스템의 가동률을 높이는 것.
- 내구성이 더 높고 견고해짐

<b>단일 장애점</b> : 다중화 되어있지 않아 시스템 전체 서비스의 계속성에 영향을 주는 컴포넌트

<i>단일 시스템의 신뢰성이 시스템 전체의 가용성을 결정함.</i>

<b>신뢰성</b> : 하드웨어나 소프트웨어가 고장나는 빈도나 고장 기간을 나타내는 개념.
시스템을 구성하는 컴포넌트에 대해 적용함.

## 클러스터링
<i>DB 서버의 다중화</i>

DB서버는 데이터를 보존하는 영속 계층이기 때문에 다중화에 대해 고민해야 할 부분이 많음.

데이터베이스는 데이터를 장기간 보존하는 매체가 필요함.  
대량의  데이터를 영구적으로 보관해야 하고 그에 따른 성능도 요구되기 때문에 데이터를 보존하는 매체에 필요한 요건이 높음.

일반적으로, 서버 내부의 로컬 저장소나 메모리로는 요건을 충족시키지 못하기 때문에 전용의 외부 저장소를 사용함.

### 데이터베이스의 구성
데이터베이스는 서버와 저장소로 구성됨.

<b>서버</b> : 계산이나 업무 로직 처리  
<b>저장소</b> : 데이터 보존

데이터는 항상 갱신되기 때문에 다중화를 유지하는 중에 <b>데이터 정합성</b>도 중요하게 의식해야함.

### 기본적인 다중화
DB 서버만을 다중화하고 저장소는 하나만 두는 구성.   
데이터가 보존되는 저장소가 1개라서 정합성을 신경 쓸 필요가 없음.

### 다중화 방법
DB 서버들이 동시에 동작하는 것을 허락할 지에 따라 나뉨.
- `Active-Active`
- `Active-Standby`
### Active-Active
> 클리스터를 구성하는 컴포넌트를 동시에 가동함.
- Oracle
- DB2

#### 장점
- 시스템 다운 시간이 짧음.
    - DB 서버가 여러대라서 한 대가 다운되어 동작하지 않아도 남은 서버가 처리를 계속해 시스템 전체가 정지하는 것을 방지함.
- 성능 향상.
    - 각 DB 서버의 CPU나 메모리가 동시에 가동므로 처리 성능이 향상됨.

#### 단점
- 저장소가 병목이 되기 때문에 생각만큼 성능이 향상되지 않을 수 있음.

![refer:http://www.ha-cc.org/typo3temp/pics/1958e453c0.png](http://www.ha-cc.org/typo3temp/pics/1958e453c0.png)
### Active-Standby
> 클리스터를 구성하는 컴포넌트 중 실제 가동하는 것은 Active, 남은 것은 대기(Standby)함

Standby 상태의 DB 서버는 사용되지 않다가 Active 서버에서 장애가 발생될 때 사용됨.  
전환될 때 까지 시차가 생기고 그 사이 시스템은 다운 상태가 됨.

#### 종류
- `cold standby`
    > 평소에는 standby가 작동하지 않다가 active DB가 다운된 시점에 작동하는 구성
- `hot standby`
    > 평소에도 standby db가 작동하는 구성
    - 전환 시간이 짧지만 그만큼 라이선스료가 높게 설정됨.
    - 항상 2개의 DB 서버를 사용하지만 실제 작동하는 DB는 active DB 1대기 때문에 매우 사치스러운 구성.

cold standby와 hot standby의 성능은 동일함.

## 리플리케이션
> DB 서버와 저장소 세트를 복수로 준비하는 것

`Active-Active`와 `Active-Standby` 클러스터 구성은 서버부분은 다중화 할 수 있어도 저장소 부분은 다중화 할 수 없으므로 저장소가 부서지면 데이터를 잃게 됨.

- 리플리케이션은 데이터를 복제함.
- DB 뿐만이 아닌 데이터도 다중화함.(데이터동기)
- 데이터베이스 서버와 저장소가 동시에 사용 불능인 경우(지진,태풍으로 인해 시설 파괴) 다른 1세트가 멀리 떨어진 지점에 놓여져 있다면 서비스를 계속 하는 것이 가능함.
- 매우 가용성이 높은 아키텍처.
- Active 측 DB 서버에 갱신된 데이터를 일정 주기로 Standby 측 DB 서버에 복제함.

### 주의할 점
- Active 측 저장소의 데이터는 항상 사용자로부터 갱신되는 것이기 때문에 Standby측 데이터도 갱신을 반영하여 최신화하지 않으면 Active 측과의 데이터 정합성을 유지할 수 없음.

### 피라미드형의 애플리케이션
- 리플리케이션 구성을 차례로 손자나 증손자 세트로 만듬.
- 데이터가 오래되어도 참조만 하면 되기때문에 처리를 손자나 증손자 세트에서 하고 부모에 걸리는 부하를 분산함.

#### 마스터 슬레이브 방식
> MySQL에서 동기화하는 측의 부모(Active)데이터베이스를 '마스터(marster)', 동기화된느 측의 자식(Standby) 데이터베이스를 '슬레이브(slave)'라고 함.


![refer:https://www.colorado.edu/webcentral/sites/default/files/styles/medium/public/article-image/db-replication.png?itok=JoIgqnpd](https://www.colorado.edu/webcentral/sites/default/files/styles/medium/public/article-image/db-replication.png?itok=JoIgqnpd)

## Shared Nothing
<i>성능을 추구하기 위한 다중화</i>

### Shared disk
> 복수의 서버가 1대의 디스크(저장소)를 사용하는 구성.

- shared disk 타입의 Active-Active 구성은 DB 서버를 늘려도 무한으로 처리율이 향상되지 않고 한계점에 도달함.
    - 저장소가 공유 자원이라서 쉽게 늘리기 어렵고, DB 서버 대수가 증가할 수록 DB 서버간의 정보 공유를 위한 오버헤드가 크기 때문.

### Shared Nothing
> 네트워크 이외 자원을 모두 분리하는 방식.
- 저장소의 병목을 해결하기 위한 기술.
- '아무것도 공유하지 않는다'라는 의미.
- 서버와 저장소의 세트를 늘리면 병렬처리 때문에 선형적으로 성능이 향상됨.
- 같은 구성의 DB 서버를 횡으로 나열하기 때문에 구조가 간단하고 원칙적으로 DB 서버 수에 비례해 저장소가 늘어감.

#### 단점
- 각각의 DB 서버가 동일한 1개의 데이터에 엑세스 할 수 없음.

![refer:http://benstopford.com/uploads/snsd2.jpg](http://benstopford.com/uploads/snsd2.jpg)


## refer
[데이터베이스 첫걸음](http://www.hanbit.co.kr/store/books/look.php?p_code=B5934047828)

