# Thread 
> 하나의 프로그램을 프로세스라고 볼 때 , 스레드는 하나의 프로그램 내에서 실행 단위, 각 작업(task)를 스레드로 표현함.

이러한 스레드를 여러 개 둘 수 있도록 함으로써 멀티 태스킹(여러 작업)을 가능하게 해줌.

- 자바 가상머신은 하나의 애플리케이션이 동시에 수행되는 여러 개의 스레드를 가질 수 있도록 함.
- 모든 스레드는 우선순위를 가짐.
- 자바 가상머신이 시작할 때는 데몬 스레드가 아닌 단 하나의 스레드가 존재하며 이 스레드는 일반적으로 실행하려는 애플리케이션의 main() 메소드를 호출하도록 되어있음.

### 스레드의 수행
자바 가상머신이 시작할 때 부터 존재하는 스레드는 다음과 같은 경우가 발생할 때 까지 계속적으로 수행됨.
- Runtime 클래스의 exit() 메소드가 호출되고 보안 관리자(security manager)가 exit 동작이 수행되도록 허락할 때.
- 스레드의 run() 메소드의 수행이 끝나고 반환되거나 stop() 메소드가 수행되는 등 데몬 스레드가 아닌 모든 스레드가 종료되었을 때.

자바는 스레드를 구현할 수 있도록
1. Thread 클래스를 상속해 확장하는 방법.
2. Runnable 인터페이스를 구현하는 방법.
등 을 제공함.

## Thread 클래스를 사용한 스레드
> Thread 클래스를 상속하는 하위 클래스 선언, 하위 클래스가 Thread 클래스의 run() 메소드를 재정의하도록 함.

- run() 메소드 : 스레드가 수행할 작업을 나타내는 스레드의 몸체 역할
- run() 메소드의 수행이 끝나고 리턴하게 되면 스레드는 종료함. 
     run() 메소드 내에는 주로 while 문을 사용해 스레드가 반복 작업을 수행하고 
     항상 살아있도록 함.

```java
import java.lang.Thread;
class ThreadNAme extends Thread{ //Thread 상속
    public void run() { // run 메소드 오버라이딩
        // Thread body
    }
}

ThreadName t = new ThreadName();
// Thread t = new ThreadName();
t.start();
```

## Runnable 인터페이스로 구현한 스레드
> Runnable 인터페이스를 구현하는 클래스 선언. Runnable 메소드를 구현하는 클래스를 선언하고 클래스의 인스턴스 생성 후 인스턴스를 Thread를 생성할 때 매개변수로 넘겨줌.

```java
import java.lang.Runnable;
class RunnableThreadName implements Runnable{
    public void run(){
     // Thread body   
    }
}

Thread t = new Thread(new RunnableThreadName);
t.start()
```

- Runnable 인터페이스는 클래스에 의해 구현되어져야 하고 이 클래스의 인스턴스는 스레드에 의해 수행되도록 되어있음.
- Thread 클래스의 하위 클래스를 만들지 않고서도 스레드로 수행 될 클래스를 만들 수 있는 방법을 제공함.
- run() 메소드만 구현하여 사용하고 Thread 클래스의 나머지 메소드는 사용할 필요가 없을 때 사용됨.


## 스레드의 종료와 대기
스레드 객체의 start() 메소드를 호출해 스레드가 시작되면 run() 메소드가 호출되고 run() 메소드가 실행되는 동안 start() 메소드는 계속 살아있음.

### 종료/대기 메소드
- stop()
    > 스레드의 수행을 강제로 정지하도록 함.  
    - 지금은 deparecated됨.(사용하지 않음)  
        [스레드가 사용 중인 자원들이 불안전한 상태로 남겨지기 때문.](http://ict-nroo.tistory.com/22)
    - `t.stop();`
- join() 
    > 스레드가 종료되기를 기다림. 0이면 영원히 기다리라는 말.
    - `t.join();`

## 스레드의 상태
스레드가 가질 수 있는 상태
![스레드의 상태](http://cfile1.uf.tistory.com/image/2036FB454FDAADEE1DCCB7)
- new Thread 
    > new 문장을 이용해 스레드를 생성하고 실행하기 바로 직전의 상태를 나타냄.
- Runnable 
    > 새로운 스레드가 생성되어 그 스레드의 start 메소드를 호출하면 스레드는 실행 가능한 Runnable 상태가 됨.
    - CPU를 실제로 할당 받아 실행되는 상태.
    - 실행 큐에서 CPU를 할당 받아 실행되기 위해 대기하는 상태

<i>상태전환은 자바 런타임 스케줄러에 의해 좌우되고 CPU를 사용하던 스레드가 다른 스레드가 실행될 수 있도록 CPU를 양보하기 위해서 yield 메소드를 사용할 수 있음</i>

- Not Runnable
    > 현재 실행 중인 스레드의 `suspend,wait,sleep` 메소드를 호출하거나 스레드가 i/o 작업을 수행할 시 Runnable 상태에서 Not Runnable 상태가 됨.
    - `suspend`: 잠시 쉬게함 -> `resume` : 쉬고 있는 스레드 다시 시작 메소드 호출 했을 때 Runnable 상태로 변함.
    - `wait` : nodify 메소드 호출 했을 때 Runnable 상태로 변함.
    - `sleep` : 주어진 시간 경과했을 시 Runnable 상태로 변함.
    - i/o : 작업을 수행했을 경우 Runnable 상태로 변함.
- Dead 
    > 스레드가 할 일을 모두 마치면 dead 상태가 됨.

    
## 스레드 우선순위, 자바 스케줄링
자바 프로그램에서 수행하는 작업에 우선순위를 부여할 수 있고 이러한 작업은 스레드로 표현되므로 스레드는 우선순위를 가지게 됨.

- 우선순위는 자바 프로그램 개발자가 스레드의 실행을 위한 스케줄링을 할 수 있는 방법을 제공함.

### 선점형 스케줄링
> 자바 런타임 스케줄러는 현재 실행 가능한 스레드들 중 우선순위가 가장 높은 스레드를 실행시켜주는데, <b>현재 실행 중인 스레드보다 더 높은 우선순위를 가진 스레드가 실행 가능 상태가 되면 자바 런타임 스케줄러가 우선순위가 더 높은 스레드를 실행시켜주는 스케줄링 방식.</b>

### 타임 슬라이싱(time-slicing)
> 같은 우선순위를 갖는 여러 개의 스레드가 동시에 실행되기를 원할 때 주어진 타임 슬라이스 만큼 스레드를 순서대로 돌아가면서 실행시키는 방식.(라운드-로빈)

- 스레드가 스레드를 생성할 경우 새로 생성되는 스레드의 우선순위는 자신을 생성시킨 스레드의 우선순위를 그대로 상속함.

### 라운드-로빈
> 운영체제 작업 운영 기법들 중 순환 순서 방식.

- 프로그램의 실행 순서 등을 결정하는 기법.
- 실행되는 프로그램이 정해진 중앙 처리 장치인 CPU 사용시간을 초과했을 경우 해당 테스크의 처리를 중단하고 맨 끝으로 돌린 후 실행 가능한 다음 작업을 처리함.

## 멀티 스레드 프로그래밍
> 자바는 여러 개의 스레드를 작성하여 사용하는 멀티 스레드 프로그래밍을 제공함.

<b>여러개의 스레드가 하나의 자원을 공유할 때 고려해야 할 점</b>

#### 공정
- 여러 개의 스레드가 하나의 컴퓨팅 자원을 사용하기 위해 동시에 접근하는 프로그램을 작성하는 경우 <b>모든 스레드가 공정하게 그 자원을 사용</b>할 수 있도록 해야함. 그렇지 못할 경우 기아 또는 교착상태를 야기함.

#### 기아
> 하나 또는 그 이상의 스레드가 원하는 자원을 얻기 위해 블록되는데 그 자원을 얻을 수 없으므로 다른 작업을 못하는 상태.

- 하나의 시스템 자원을 얻지 못하고 계속 블록되어 있는 상태.

#### 교착상태
> 두개 이상의 스레드가 만족하지 못한 상태로 계속 기다릴 때 발생. 두개 이상의 스레드가 서로 어떤 일을 해주기를 기다리는 상태.

- 한 스레드가 먼저 포기하지 않는 이상 영원히 기다림
- 스레드간의 동기화가 필요함.

### 생성자,요청자 문제
생성자 : 항상 어떤 것을 생성함.
요청자 : 생성자가 생성한 것을 요청하여 가져다 사용함.

<i>생성자/요청자가 정수 값을 공유할 때</i>

#### 경주상태
- 생성자가 요청자보다 빠를 경우 요청자가 가져가기도 전에 다른 정수를 생성하므로 전에 생성된 정수는 전혀 요청자에 의해 사용될 수 없음.
- 요청자는 속도 차에 의해 하나 또는 그 이상의 수들을 놓침.
- 요청자는 같은 값을 두번 이상 가져가 사용할 수 있음.

### 해결
동기화 될 수 있도록 해줘야함. `모니터,notify,wait`

### 비동기 스레드
> 각 스레드가 자신이 실행 될 때 필요로 하는 모든 데이터와 메소드를 포함하고, 다른 외부 자원이나 메소드를 전혀 필요로 하지 않는 스레드

반면, 비동기 스레드와 다른 스레드

> 서로 독립적으로 실행되더라도 서로 데이터를 공유하고 다른 스레드의 상태 또는 행동들을 고려해 수행되는 스레드

<b>하나의 같은 자원을 공유하여 원하는 결과를 얻기 위해 반드시 동기화 될 필요가 있음.</b>

## 스레드의 동기화
### 모니터

#### 상태 변수
> 두개의 스레드에 의해 공유되고 그 값이 참조될 때 반드시 동기화되어야하는 객체.
ex) sharedData

- 모니터는 두 개의 스레드가 동시에 같은 변수에 접근하는 것을 방지해줌.
- 상태 변수라는 특별한 데이터 아이템과 데이터에 대해 lock을 걸도록 작동되는 기능과 관련됨.
- 스레드가 어떤 아이템에 대한 모니터를 갖게 되었을 때 다른 스레드는 lock이 되어 그 데이터를 참조하거나 변경할 수 없도록 함.

#### 임계영역
> 서로 별개이면서 동시에 실행되고 있는 스레드들에 의해 같은 데이터가 참조될 수 있는  코드 세그먼트

- synchronized 키워드로 임계영역 생성
```java
synchronized static int getId(){
    // 클래스 메소드
}

synchronized int get(){
    // 인스턴스 메소드
    synchronized(this){
        // synchronized code
    }
}
```
- synchronized 메소드를 갖는 모든 객체는 하나의 고유한 모니터를 갖게 됨.

#### 모니터 재진입
- 같은 스레드는 이미 잡고있는 모니터를 synchronized 메소드를 호출할 수 있으므로 모니터를 재획득이 가능함.
- 자바 런타임 시스템은 이미 다른 스레드에 의해 잡혀있는 모니터라도 다른 스레드가 재획득 할 수 있도록 해줌.


### notifyAll(), wait()
- 상태 변수 내에 메소드들은 값을 위치시키고 얻는 것을 중재하기 위하여 notifyAll(),wait() 메소드를 사용함.
- 이 메소드들은 모두 lock을 잡고있는 스레드에 의해서만 호출될 수 있음.


### notifyAll()
> 현재 스레드에 잡혀있는 모니터 상에서 기다리고 있는 <b>모든</b> 스레드에게 통보하여 깨워줌.

- object 클래스의 메소드
- 일반적으로 기다리고 있는 스레드 중 하나가 모니터를 잡고 자신의 일을 처리할 수있음.
- 여러 개의 스레드들이 하나의 모니터를 기다리고 있다면 자바 런타임 머신은 실행하기 위해 기다리고 있는 스레드 중 하나를 선택해줌. 이 때, 어떤 스레드가 선택될 지는 보장할 수 없음.


### notify()
> 해당 모니터를 기다리고 있는 스레드 중 하나를 마음대로 깨움.

- object 클래스의 메소드
- notifyAll() 에 비해 안정적이지 않음.

### wait)
> 현재 스레드는 다른 스레드가 상태 변화에 대해 통보할 때 까지 기다림.

- 같은 자원을 여러 개의 스레드가 사용할 때 이의 중재를 위해 notifyAll() 메소드와 결합해 wait() 메소드를 사용할 수 있음.

```java
// 생성자 put 메소드
public synchronized void put(int value){
    while(avaliable==true){ // get 메소드가 호출되어 값을 get 했을 시 false로 바뀜
    // 요청자  스레드가 값을 소비할 때 까지 
        try{
            wait(); // 기다림
        }catch(InterruptedException e){}
    }
    contents = value;
    avaliable = ture; // 값 생성
    notifyAll();
}

...

public synchronized int get(){
    while(avaliable==false){ // 생성자 스레드가 값을 생성할 때 까지
        try{
            wait();// 기다림
        }catch(InterruptedException e){}
    }
    avaliable = false;
    notifyAll();
    return contents;
}
```
